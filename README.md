# ğŸ§  DSA Python Prep

<div align="center">
  
  ![Python](https://img.shields.io/badge/Python-3.x-blue.svg)
  ![License](https://img.shields.io/badge/license-MIT-green.svg)
  
  **My personal journey through Data Structures and Algorithms using Python**
</div>

After previously learning Data Structures and Algorithms in Java, I'm now revisiting these concepts with a Pythonic approach.
This repository documents my learning process as I tackle carefully selected DSA problems. I'm sharing my progress publicly to stay accountable and, hopefully, to help others on similar journeys.

> ğŸ¯ **Goal**: Build robust problem-solving skills in Python, advancing systematically from fundamental to advanced DSA concepts.

## ğŸ“‹ About This Journey

This repository serves as a long-term preparation for coding interviews, with a target of securing a software engineering role by 2027. Although that may seem far away, I am taking a proactive approach to build my problem-solving skills early. I plan to venture into various DSA concepts, continuously refining my understanding through consistent practice.

My goal is to develop a robust foundation in Data Structures and Algorithms using Python, building on my previous experience with Java. Each solution includes:

* **Clean, well-documented code** with Pythonic practices
* **Detailed thought process** and approach explanation
* **Complexity analysis** (time and space)
* **Alternative solutions** when applicable
* **Reflections** on challenges and learning takeaways

## ğŸ“‚ Target Repository Structure

```
dsa-python-prep/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ Arrays_and_Strings/
â”‚   â”œâ”€â”€ Linked_Lists/
â”‚   â”œâ”€â”€ Recursion/
â”‚   â”œâ”€â”€ Sorting_Algorithms/
â”‚   â”œâ”€â”€ Stacks_and_Queues/
â”‚   â”œâ”€â”€ Trees_and_Graphs/
â”‚   â”œâ”€â”€ Dynamic_Programming/
â”‚   â”œâ”€â”€ Greedy_Algorithms/
â”‚   â”œâ”€â”€ Backtracking/
â”‚   â”œâ”€â”€ Bit_Manipulation/
â”‚   â””â”€â”€ Design_Patterns/
â””â”€â”€ README.md
```

Each concept folder contains:

* ğŸ“ **Problem solutions** with detailed comments and explanations
* ğŸ“Š **Visual illustrations** for complex algorithms where helpful
* ğŸ““ **Implementation notes** highlighting Python-specific techniques
* ğŸ” **Pattern recognition** guidelines to identify similar problems

## âœ… Progress Tracker

### Fundamentals
- [x] **Big O Analysis** - Time and space complexity evaluation
- [x] **Problem-solving strategies** - Breaking down problems systematically
- [x] **Pythonic patterns** - Leveraging language features effectively

### Data Structures
- [x] **Arrays/Lists**
  - [x] Traversal techniques
  - [x] In-place operations
  - [x] Sliding window
  
- [ ] **Linked Lists**
  - [ ] Singly linked lists
  - [ ] Doubly linked lists
  - [ ] Fast/slow pointer techniques
  
- [ ] **Stacks & Queues**
  - [ ] Implementation variants
  - [ ] Application problems
  
- [ ] **Hash Tables**
  - [ ] Dictionary implementations
  - [ ] Collision resolution

### Algorithms
- [x] **Sorting Algorithms**
  - [x] Insertion Sort
  - [x] Selection Sort
  - [x] Quick Sort
  - [x] Merge Sort
  - [ ] Heap Sort
  
- [x] **Searching Algorithms**
  - [x] Binary Search and variants 
  - [x] Linear search optimizations

- [ ] **Recursion** *(Focus Area)*
  - [ ] Recursive thinking patterns
  - [ ] Base cases and recursive cases
  - [ ] Tree-based recursion
  - [ ] Memoization techniques
  - [ ] Tail recursion optimization

### Advanced Concepts
- [ ] **Trees**
  - [ ] Binary Trees
  - [ ] Binary Search Trees
  - [ ] Balanced Trees (AVL, Red-Black)
  - [ ] Tree Traversals (In-order, Pre-order, Post-order, Level-order)
  
- [ ] **Graphs**
  - [ ] Representation (Adjacency Matrix/List)
  - [ ] Traversal (DFS, BFS)
  - [ ] Shortest Path Algorithms (Dijkstra's, A*)
  - [ ] Minimum Spanning Trees (Prim's, Kruskal's)
  
- [ ] **Dynamic Programming**
  - [ ] Top-down approach (Memoization)
  - [ ] Bottom-up approach (Tabulation)
  - [ ] State transition patterns
  
- [ ] **Greedy Algorithms**
  - [ ] Activity selection
  - [ ] Huffman coding
  
- [ ] **Backtracking**
  - [ ] Constraint satisfaction problems
  - [ ] Combinatorial problems

## ğŸ› ï¸ Setup & Usage

```bash
# Clone repository
git clone https://github.com/nathangtg/dsa-python-prep.git
cd dsa-python-prep

# Set up virtual environment (recommended)
python3 -m venv .venv
source .venv/bin/activate  # On Windows: .venv\Scripts\activate

# Install dependencies (if any)
pip install -r requirements.txt

# Run a specific solution
python src/Arrays_and_Strings/two_sum.py
```

## ğŸ“š Study Approach

I follow a methodical learning process:

1. **Understand the concept** - Study the underlying theory
2. **Implement from scratch** - Write my own implementation without references
3. **Optimize** - Refine for efficiency and readability
4. **Generalize** - Identify patterns for future application
5. **Review** - Periodic revision of previously solved problems

### Weekly Focus Areas

Each week focuses on:
- ğŸ§© **Core concept** (e.g., Recursion, Trees)
- ğŸ”„ **Implementation variations**
- ğŸ”— **Connections to related problems**
- ğŸ“ˆ **Progressive difficulty increase**

## ğŸ§  Problem-Solving Framework

For each problem, I follow this structured approach:

1. **Understand** - Clarify inputs, outputs, constraints
2. **Visualize** - Draw examples, identify patterns
3. **Brute Force** - Develop initial working solution
4. **Optimize** - Improve algorithm efficiency
5. **Implement** - Write clean, documented code
6. **Test** - Verify with multiple test cases
7. **Reflect** - Document learnings and alternate approaches

## ğŸ—’ï¸ Learning Journal

Each implementation includes a learning journal with:

- ğŸ’¡ **Key insights** gained while solving
- ğŸ”‘ **Pattern recognition** for future reference
- ğŸš§ **Challenges encountered** and how they were overcome
- ğŸ” **Optimization opportunities** identified
- ğŸ“ **Personal notes** on Pythonic implementations

## ğŸ“Š Personal Growth Metrics

I track my progress through:

- **Problem-solving speed** improvement
- **Solution quality** enhancements
- **Pattern recognition** ability
- **Algorithm complexity** understanding
- **Code readability** and elegance

## ğŸ”„ Revision Strategy

To ensure long-term retention:

- Weekly review of previously solved problems
- Periodic implementation of the same problem with different approaches
- Themed practice sessions focusing on specific patterns
- Spaced repetition for challenging concepts

---

<div align="center">
  *This repository represents my personal learning journey. Constructive feedback is welcome as the solutions reflect my evolving understanding of DSA concepts.*
</div>